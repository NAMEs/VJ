V={};
(function(V,$){
	//V基本操作与类定义
	V.isValid = function (data) {
		if (typeof (data) != "undefined" && data != null && data != 'null' && !(data === '')) {
			return true;
		} else {
			return false;
		}
	};
	V.getValue = function (data, defaultData) {
		return V.isValid(data) ? data : defaultData;
	};
	V.getType = function (x) {
		if (x == null) {
			return "null";
		}
		var t = typeof x;
		if (t != "object") {
			return t;
		}
		var c = Object.prototype.toString.apply(x);
		c = c.substring(8, c.length - 1);
		if (c != "Object") {
			return c;
		}
		if (x.constructor == Object) {
			return c;
		}
		if (x.prototype && "classname" in x.prototype.constructor
				&& typeof x.prototype.constructor.classname == "string") {
			return x.constructor.prototype.classname;
		}
		return "ukObject";
	};
	V.format = function(s,o){
		var reg = /<%=[^(%>)]+%>/gi;
		return s.replace(reg,function(word){
			var prop = word.replace(/<%=/g,'').replace(/%>/g,'');
			if(o[prop]){
				return o[prop];
			}else{
				return "";
			}
		});
	};	
	V.inherit = function(parent,args){
		//绕过了parent的构造函数，重新链接原型链条
		var _temp = (function(){
			var F = function(){};
			F.prototype = parent.prototype;
			F.prototype.isF = true;
			return new F();
		})();
		_temp.constructor = parent;
		if(!this.prototype){			
			//这里确认是实例
			//确定是打断了原型链 使得this的原型为Object		
			parent.apply(this,args);		
			//从新接驳原型链 使得原型链上的prototype都设置到最早的类的prototype上了
			if(!this.__proto__.isF){
				this.__proto__.constructor.prototype = _temp.__proto__.constructor.prototype;
			}	
			//son.prototype = _temp; //这里可以分层 但是会使得prototype实例变了又变 废弃
			this.__proto__ = _temp;
			this.base = this.__proto__.constructor.prototype;
		} else {
			console.log('如果失败，需要配合子类构造函数中使用parent.apply(this,[***])');
			//这里确认是类定义
			this.prototype = _temp;
		}
	};
	V.isDebug = false;
	V.showException = function (name, e) {
    if (V.isDebug) {
        var content = name;
        if (V.isValid(e)) {
            content += ("\r\nname:" + e.name + "\r\nmessage:" + e.message + (V.userAgent.firefox ? ("\r\nstack:" + e.stack + "\r\nfile:" + e.fileName + "\r\nlineNumber:" + e.lineNumber) : (V.userAgent.ie ? ("\r\ndescription:" + e.description) : "")));
        }
        //V.alert('未捕获异常',content);
        //alert('未捕获异常:' + content);
        console.log('未捕获异常:' + content);
    }
};
V.userAgent = {
    ie: false,
    firefox: false,
    chrome: false,
    safari: false,
    opera: false
};
{
    var ua = navigator.userAgent.toLowerCase();
    var s;
    (s = ua.match(/msie ([\d]+)/)) ? V.userAgent.ie = s[1] :
    (s = ua.match(/firefox\/([\d.]+)/)) ? V.userAgent.firefox = s[1] :
    (s = ua.match(/chrome\/([\d.]+)/)) ? V.userAgent.chrome = s[1] :
    (s = ua.match(/opera.([\d.]+)/)) ? V.userAgent.opera = s[1] :
    (s = ua.match(/version\/([\d.]+).*safari/)) ? V.userAgent.safari = s[1] : 0;
    for (key in V.userAgent) { if (V.getValue(V.userAgent[key], false)) { V.userAgent.name = key; } }
    V.showException("VJ.userAgent:" + V.userAgent.name);
    if (V.getValue(V.userAgent.ie, false)) {
        var ver = V.userAgent.ie;
        eval('VJ.userAgent.ie' + ver + ' = true;VJ.userAgent.name=\'ie' + ver + '\';');
    }
}
	V.tryC = function (func) {
		try {
			return func();
		} catch (e) { V.showException('', e); }
	};
	V.each = function(data,func,timeout){
		var _ = this;
		var index = 0;
		data = Array.prototype.slice.call(data, 0);
		timeout = 1 || timeout;
		var _func = function () {
			if (index < data.length) {
				window.setTimeout(function () {V.tryC(function() {
					try {
						func.apply(_, [index, data[index]]);
					} finally {
						index++;
						_func.apply(_, []);
					}
				});}, timeout);
			}
		}
		_func.apply(_, []);
	};
	V.once = function(func,timeout){
		timeout = 100 || timeout;
		if(func.timeoutID){
			window.clearTimeout(func.timeoutID);
		}
		var _ = this;
		func.timeoutID = window.setTimeout(function(){V.tryC(function(){func.apply(_,[])})},timeout);
	};	
	V.isArray = function (obj) {
		return Object.prototype.toString.call(obj) === '[object Array]';
	};
	V.encHtml = function (html) {
		//20120328 白冰 只转换标点符号!    
		//return encodeURIComponent(V.getValue(html, '').replace(/\r\n/g, ''));
		console.log((V.getValue(html, '').replace(/\s/g, ' ')));
		return (V.getValue(html, '').replace(/\s/g, ' ').replace(/\r\n/g, '')).replace(new RegExp('~|!|@|#|\\$|%|\\^|;|\\*|\\(|\\)|_|\\+|\\{|\\}|\\||:|\"|\\?|`|\\-|=|\\[|\\]|\\\|;|\'|,|\\.|/|，|；', 'g'), function (a) { return encodeURIComponent(a); });
	};
	//对字符串进行解码
	V.decHtml = function (html) {
		return decodeURIComponent(V.getValue(html, ''));
	};
	//处理自定义TJson格式 如一般是[包[库[表[行]]]] [['Rindex','ID'],['1','6e014f804b8f46e1b129faa4b923af2d'],['2','6e014f804b8f46e1b129faa4b923a23d']]
	V.evalTJson = function (data) {
		//转换表用的
		var _evalTJson = function (_dt) {
			var res = [];
			$(_dt).each(function (i, v) {
				if (0 == i) return;
				var s = {};
				$(v).each(function (q, v2) {
					s[_dt[0][q]] = v2;
				});
				res[i - 1] = s;
			});
			return res;
		};
		data = data[0];
		var res = [];
		$(data).each(function (i, v) {
			res[i] = _evalTJson(v);
		});
		return res;
	};
	//用于数组，对象的深度合并功能。moveIndex属性用于设定移动至的位置，mergeIndex只用于合并数组中的第几个对象 需要进入reference
//例如
//var ret = V.merge({a:22,c:23},{a:34,b:33},{d:"2334",f:true,g:function(){alert("hahaha");}},{h:[1,2,3,4]});
//var ret = V.merge({a:[{a:2},{b:3}]},{a:[{moveIndex:3,j:3},{k:4}],b:25});
//var ret = V.merge({a:[{a:2},{b:3}]},{a:[{mergeIndex:3,j:3},{k:4}],b:25});
V.merge = function () {
    var _clone = function (source) {
        switch (V.getType(source)) {
            case 'Object':
                return _merge({}, source);
                break;
            case 'Array':
                var aim = [];
                for (i in source) {
                    aim[i] = _clone(source[i]);
                }
            default:
                return source;
                break;
        }
    };
    var _merge = function (aim, source) {
        if (!(typeof (source) == 'object' && typeof (source.length) == 'undefined')) { return aim; }
        for (var i in source) {
            if (V.isValid(source[i])) {
                if (!V.isValid(aim[i])) {
                    aim[i] = _clone(source[i]);
                } else {
                    switch (V.getType(aim[i])) {
                        case 'Object':
                            _merge(aim[i], source[i]);
                            break;
                        case 'Array':
                            //处理数组
                            var hasmergeIndex = false;
                            for (var i3 = 0, k = source[i][i3]; i3 < source[i].length; i3++, k = source[i][i3]) {
                                if (typeof (k.mergeIndex) == "number") {
                                    hasmergeIndex = true;
                                    if (aim[i].length < (i3 + 1)) {
                                        aim[i].push(k);
                                    } else {
                                        aim[i][i3] = _merge(aim[i][i3], k);
                                    }
                                } else if (typeof (k.moveIndex) == "number") {
                                    hasmergeIndex = true;
                                    aim[i].splice(k.moveIndex, 0, k);
                                }
                            }
                            if (!hasmergeIndex) {
                                aim[i] = _clone(source[i]);
                            }
                            break;
                        default:
                            aim[i] = source[i];
                            break;
                    }
                }
            }
        }
        return aim;
    };
    var argu = arguments;
    if (argu.length < 2) { return argu[0] ? argu[0] : {} };
    var _ = {};
    for (var i2 = 0; i2 < argu.length; i2++)
        _ = _merge(_, argu[i2]);
    return _;
};
	V.include = function(){};
	/* 生成新元素
	*-- 参数1：tag 标签
	*-- 参数2：样式class
	*-- 参数3：标签内内容
	*-- 案例：V.newEl("div","divClass","我的div");
	*/
	V.newEl = function (tag, style, txt) {
		var elm = $(document.createElement(tag));
		if (txt != "") {
			elm.text(txt);
		}
		if (style != "") {
			elm.addClass(style);
		}
		return elm;
	};
})(V,jQuery);